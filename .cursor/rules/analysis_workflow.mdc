---
description: Pre-Execution Analysis Orchestrator — continuous analysis workflow
alwaysApply: false
---

## Pre-Execution Analysis Workflow (Common-Sense, Advisory by Default)

Objective: Compare `memory-bank/queue-system/tasks_active.json` (execution plan) directly against the codebase to detect conflicts, missing contracts, policy drift, and sequencing issues. Keep execution unblocked by default; surface actionable findings.

### Inputs
- Execution plan: `memory-bank/queue-system/tasks_active.json` (array, exactly one task)
- Repo root: repository top-level (auto-detected)

### Method
1. Read the execution plan `tasks_active.json` and iterate phases K=0..N.
2. For each phase K, infer expected artifacts/contracts (schemas, commands, files, services) from phase text.
3. Cross-check against the codebase:
   - Presence/shape of referenced files/schemas/configs
   - Policy contracts (e.g., timestamps, correlation_id, schema versions)
   - Test/coverage targets, CI configs, scanners, performance harness
   - Integration points (routing, orchestrator, memory, docs, observability)
4. Record concise findings per phase (Duplicate/Overlap/Conflict/Missing) with evidence (paths/symbols/lines).
5. Summarize risks and suggested fixes; do not block execution by default.

### Commands (reference; advisory)
```bash
python3 plan_next.py
python3 plain_hier.py <TASK_ID>
# Optional analyzers (read-only): grep/rg checks, schema validators, config linters
```

### Completion
- Emit: "Analysis Complete — Findings available; execution may proceed."

### IMPORTANT NOTE
- Advisory by default (solo/shadow modes). Blocking only when enforcement escalates per policy.
- Focus on plan-vs-codebase consistency; do not auto-edit the plan without operator approval.

